0000                             ;MACHINE:	EQU	1	; "AL80"
0000                MACHINE:   EQU   2   ; "MintZ80"
0000                OFFSET:   EQU   2400h   ; offset of memory start for the program. Originally 0
0000                             ; VTL2.ASM
0000                             ; ------------
0000                             ; 
0000                             ; MITS VTL-2 -- A Very Tiny Language for the Altair 8800
0000                             ; by Frank McCoy, Copyright 1976, 2007
0000                             ; Version 3.0
0000                             ; 
0000                             ; 
0000                CASSTS:   EQU   6   ; Cassette Status
0000                CASSTD:   EQU   7   ; Cassette Data
0000                UART_BASE:   EQU   008h   ; Base port address, P8250A/USART uses 8 ports.
0000                UART0:    EQU   UART_BASE+00h   ;Data in/out
0000                UART1:    EQU   UART_BASE+01h   ;Check RX
0000                UART2:    EQU   UART_BASE+02h   ;Interrupts
0000                UART3:    EQU   UART_BASE+03h   ;Line control
0000                UART4:    EQU   UART_BASE+04h   ;Modem control
0000                UART5:    EQU   UART_BASE+05h   ;Line status
0000                UART6:    EQU   UART_BASE+06h   ;Modem status
0000                UART7:    EQU   UART_BASE+07h   ;Scratch register		
0000                SIO_BASE:   EQU   018h   ; SIO port
0000                SIO_DA:   EQU   SIO_BASE   
0000                SIO_CA:   EQU   SIO_BASE+1   
0000                SIO_DB:   EQU   SIO_BASE+2   
0000                SIO_CB:   EQU   SIO_BASE+3   
0000                             ;--------------------------------
0000                             ; MITS Altair or Imsai 8800 I/O ports used:
0000                             ; If your system has one of these board's I/O addressed at a
0000                             ; non-standard location, then just change the appropriate
0000                             ; definition of the three below; and reassemble the program.
0000                             ; 
0000                             ;SIOBRD	EQU	0	; MITS Single-SIO board usually Port-0
0000                             ;SIO2BRD	EQU	16	; MITS Dual-SIO board usually Ports-16 & 18
0000                             ;PTPLUSS	EQU	0	; Processor-Technology 3P+S board at Port-0
0000                             ; 
0000                             ; 
0000                             ; The bits input from the SENSE switches are defined as follows:
0000                             ;    00000000B
0000                             ;        | ||
0000                             ;        | ||    0 = MITS SIO  board at Port-0  (Default)
0000                             ;        | |+----1 = MITS 2SIO board at Port-16
0000                             ;        | +-----2 = Processor-Technology 3P+S board at Port-0
0000                             ;        +-------8 = MITS 2SIO board at Port-18
0000                             ; 
0000                             ; The bits are tested in-order, right-to-left
0000                             ; 2SIO at 16 first 3P+S second, 2SIO at 18 third.
0000                             ; If none of the three bits are set, then is MITS SIO board.
0000                             ; The odd grouping is for compatibility with MITS software;
0000                             ; Specifically MITS BASIC.
0000                             ; 
0000                             ; Thus default (00H) assumes a single MITS SIO board at port-0
0000                             ; 
0000                             ;SENSE	EQU	0FFH	; Sense-Switches at 0xFF on Altair 8800
0000                             ; 
0000                             ; From above, we get the following:
0000                             ; 
0000                             ;SIOS	EQU	SIOBRD	; MITS Single SIO board Status
0000                             ;SIOD	EQU	SIOS+1	; MITS Single SIO board Data
0000                             ; 
0000                             ;SIOS0	EQU	SIO2BRD	; MITS 2SIO Board Lower Status
0000                             ;SIOD0	EQU	SIOS0+1	; MITS 2SIO Board Lower Data
0000                             ;SIOS1	EQU	SIOS0+2	; MITS 2SIO Board Upper Status
0000                             ;SIOD1	EQU	SIOS1+1	; MITS 2SIO Board Upper Data
0000                             ; 
0000                             ;PTSS	EQU	PTPLUSS	; Processor-Technology 3P+S Serial Status
0000                             ;PTSD	EQU	PTSS+1	; Processor-Technology 3P+S Serial Data
0000                             ; 
0000                             ; 
0000                             ; I/0 byte equates:
0000                             ; 
0000                CLEAR:    EQU   01H   ; Clear 2SIO boards
0000                INTCI:    EQU   11H   ; Sets clock and interupts on 2SIO boards
0000                             ; 
0000                             ;--------------------------------
0000                             ; ASCII characters used (ASR-33 Teletype).
0000                             ; 
0000                CTRLC:    EQU   03H   ; Abort key (Control-C)
0000                LF:       EQU   0AH   ; Line-Feed
0000                CR:       EQU   0DH   ; Carriage-Return
0000                             ;--------------------------------
0000                             ;       Buffer area
0000                             ;-------------------------------- (SV = System Variable)
0000                             ;-------------------------------- (GV = Usable Variable)
0000                             ; 
2400                          .ORG   0000H+OFFSET   ; Bottom of memory
2400                BRKPNT:   DS   0   ; Address of RST 0
2400                RST0:     DS   8   ; Restarts
2408                RST1:     DS   8   ; 
2410                RST2:     DS   8   ; 
2418                RST3:     DS   8   ; 
2420                RST4:     DS   8   ; 
2428                RST5:     DS   8   ; 
2430                RST6:     DS   8   ; 
2438                RST7:     DS   8   ; 
2440                AT:       DS   2   ; SV: Usable storage since "@" not allowed
2442                VARS:     DS   52   ; Variables A - Z (26 variables)
2476                BRAK:     DS   2   ; [
2478                SLISH:    DS   2   ; \
247A                BRIK:     DS   2   ; ]
247C                UP:       DS   2   ; ^ SV: Number of terminal option running
247E                LINPTR:   DS   2   ; _ SV: Current line-pointer save
2480                SPAC:     DS   2   ;   GV: Space
2482                EXCLAM:   DS   2   ;   SV: RETURN pointer (Excalmation-Point)
2484                QUOTE:    DS   2   ; "
2486                NUMBR:    DS   2   ; # SV: Line-Number
2488                DOLLAR:   DS   2   ; $ SV: Character pointer
248A                PERCNT:   DS   2   ; % SV: Remainder after divide
248C                AMPERS:   DS   2   ; & SV: Next byte past user program - Array start
248E                QUITE:    DS   2   ; ' SV: Random Number
2490                PAREN:    DS   2   ; ( SV: Not used
2492                PARIN:    DS   2   ; ) SV: Not used
2494                STAR:     DS   2   ; * SV: Next byte past user program (Array area)
2496                PLUS:     DS   2   ; + GV: General Purpose variable
2498                COMMA:    DS   2   ; , SV: Number of nulls after each cr/lf
249A                MINUS:    DS   2   ; - GV: General Purpose variable
249C                PERIOD:   DS   2   ; . SV: Terminal echo switch
249E                SLASH:    DS   2   ;   SV: General Purpose variable
24A0                             ; 
24A0                EVALPT:   DS   2   ; 0 Eval pointer
24A2                SV1:      DS   2   ; 1 SV: Not used
24A4                SV2:      DS   2   ; 2 SV: Not used
24A6                SV3:      DS   2   ; 3 SV: Not used
24A8                SV4:      DS   2   ; 4 SV: Not used
24AA                SV5:      DS   2   ; 5 SV: Not used
24AC                RESULT:   DS   2   ; 6 SV: Result of expression evaluation
24AE                LINUMB:   DS   2   ; 7 SV: Line number
24B0                CURENT:   DS   2   ; 8 SV: Current line number
24B2                VALVAR:   DS   2   ; 9 SV: Value of variable?
24B4                             ; 
24B4                COLN:     DS   2   ; : GV: General purpose variable
24B6                SEMI:     DS   2   ; ; GV: General Purpose variable
24B8                LESS:     DS   2   ; < GV: General Purpose variable
24BA                EQAL:     DS   2   ; = GV: General Purpose variable
24BC                GRAT:     DS   2   ; > SV: Return-value from Machine-language
24BE                             ; 
24BE                DECBUF:   DS   4   ; Decimal buffer ("54321")
24C2                LASTD:    DS   1   ; Last byte in decimal-buffer
24C3                DELIM:    DS   1   ; Delimiter space for buffer-end
24C4                LINBUF:   DS   72   ; Line buffer (TTY = 72 Characters)
250C                             ; 
250C                             ;--------------------------------
250C                             ;	User program
250C                             ;--------------------------------
250C                             ; 
2540                          .ORG   0140H+OFFSET   ; = 320 in decimal
2540                             ; 
2540                STACK:    EQU   $   ; Stack goes from here down to line-buffer
2540                PRGM:     EQU   $   ; Programming space: here to end of memory
2540                             ; 
2540                             ;--------------------------------
2540                             ;       Main operating system
2540                             ;--------------------------------
2540                             ; 
F800                          .ORG   0F800H   ; Probably a ROM
F800                             ; 
F800                             ; Cold-Start ("Boot").
F800                             ; 
F800   3E 01        RSTRT:    MVI   a,01   
F802   D3 F8                  OUT   0f8h   
F804   21 01 00               LXI   H,CLEAR   ; = 3 to clear various things
F807   22 9C 24               SHLD   PERIOD   ; To see the program as it comes in
F80A   21 00 00               LXI   H,0   ; no null after CRLF
F80D   22 98 24               SHLD   COMMA   ; Number of nulls after each cr/lf
F810                             ; 
F810                             ; By default, VTL-2 expects that the MITS Altair 8800 system
F810                             ; it is running on has a terminal via one 2SIO board, either
F810                             ; at I/O port 16, or at port 18. Since it has no way to know
F810                             ; which one will be used, it simply initialize the 2SIO board
F810                             ; at both I/O ports...
F810                             ; 
F810                             ;	skip init. We're entering from monitor or boot loader and SIO ports are initialized
F810                             ;	MOV	A,L	; = 3 Resets the chip of the 2SIO board
F810                             ;	OUT	SIOS0	; I/O port 16 = 2SIO board Status
F810                             ;	OUT	SIOS1	; I/O port 18 = 2SIO board Status
F810                             ;	MVI	A,INTCI	; = 17 Sets the clock and interrupts
F810                             ;	OUT	SIOS0	; I/O port 16 = 2SIO board Status
F810                             ;	OUT	SIOS1	; I/O port 18 = 2SIO board Status
F810                             ; 
F810                             ; 
F810                             ; 
F810                             ; Warm-Start (Ctrl-C).
F810                             ; 
F810                             ; On Entry, register contents don't matter.
F810                             ; 
F810   31 40 25     START:    LXI   SP,STACK   ; Set up stack (before user program)
F813   AF                     XRA   A   ; Initialize delimiter
F814   32 C3 24               STA   DELIM   ; Save delimiter for decimal-printing
F817   21 AB FB               LXI   H,OKM   ; Point to "OK" prompt
F81A   CD 8C FB               CALL   STRNG   ; Display it on terminal
F81D                             ; 
F81D                             ; Main loop of VTL-2 interpreter.
F81D                             ; 
F81D                             ; BC: ?, DE: ?, HL: ?
F81D                             ; 
F81D   21 00 00     LOOP:     LXI   H,0000H   ; Clear line-number for fall-through
F820   22 86 24               SHLD   NUMBR   ; If no change during this line, then next
F823   CD 33 FB               CALL   CVTLN   ; Was a line number inputted?
F826   D2 80 F8               JNC   STMNT   ; 0: List (display) user program statements
F829   CD 6F F8               CALL   EXEC   ; If no line, then execute direct statement
F82C   CA 10 F8               JZ   START   ; If end, then stop
F82F                             ; 
F82F   CD BA F8     LOOP2:    CALL   FIND   ; Load real line-number
F832                             ; 
F832                             ; Start processing "=" statements.
F832                             ; 
F832   D2 10 F8     EQSTRT:   JNC   START   ; If end, then stop
F835                             ; 
F835   CD 65 F8               CALL   LXHN   ; Get real line number
F838   22 86 24               SHLD   NUMBR   ; And save it for program
F83B   2A 7E 24               LHLD   LINPTR   ; Get crrent spot in line
F83E   23                     INX   H   ; Bump past 0-byte delimiter
F83F   23                     INX   H   ; Bump past line-number
F840   23                     INX   H   ; 
F841   CD 6F F8               CALL   EXEC   ; Execute statement in line
F844                             ; 
F844   EB                     XCHG      ; 
F845   CA 58 F8               JZ   LOOP3   ; If line-number == 0, then continue
F848   2A 7E 24               LHLD   LINPTR   ; Else get new line
F84B   CD 65 F8               CALL   LXHN   ; and see if it's changed
F84E   CA 58 F8               JZ   LOOP3   ; If unchanged, then continue
F851   23                     INX   H   ; Else, increment old line-number
F852   22 82 24               SHLD   EXCLAM   ; And save as RETURN value
F855   C3 2F F8               JMP   LOOP2   ; Then continue at new line
F858                             ; 
F858   E5           LOOP3:    PUSH   H   ; Save line number
F859   2A 8C 24               LHLD   AMPERS   ; Next byte of user program
F85C   44                     MOV   B,H   ; 
F85D   4D                     MOV   C,L   ; Copy it into BC
F85E   E1                     POP   H   ; Restore line number
F85F   CD D9 F8               CALL   FND3   ; Find next line
F862   C3 32 F8               JMP   EQSTRT   ; And THEN continue
F865                             ; 
F865                             ;--------------------------------
F865                             ; Get line number from user program.
F865                             ; 
F865   7E           LXHN:     MOV   A,M   ; 
F866   23                     INX   H   ; 
F867   66                     MOV   H,M   ; 
F868   6F                     MOV   L,A   ; 
F869                             ; 
F869                             ; ... and falls through
F869                             ; 
F869                             ; Compare HL with DE.
F869                             ; 
F869   7D           CPHD:     MOV   A,L   ; 
F86A   BB                     CMP   E   ; First test high bytes
F86B   C0                     RNZ      ; Done, if not same
F86C   7C                     MOV   A,H   ; 
F86D   BA                     CMP   D   ; Else test low bytes
F86E   C9                     RET      ; 
F86F                             ; 
F86F                             ;--------------------------------
F86F                             ;	Execute direct statements.
F86F                             ; 
F86F   22 AE 24     EXEC:     SHLD   LINUMB   ; Save line position for store
F872   CD F5 FA               CALL   VAR2   ; Skip past variable or array-element
F875                             ; 
F875   23                     INX   H   ; Get first term
F876   7E           SKIP:     MOV   A,M   ; 
F877   CD DF F8               CALL   EVIL   ; Evaluate expression
F87A                             ; 
F87A   2A 86 24     OUTX:     LHLD   NUMBR   ; Get char ptr
F87D   7C                     MOV   A,H   ; 16-bits test if it is zero
F87E   B5                     ORA   L   ; (Sets Zero flag)
F87F   C9                     RET      ; 
F880                             ; 
F880                             ;--------------------------------
F880                             ;	List (display) user program statements.
F880                             ; 
F880                             ; BC: ?, DE: ?, HL: ?
F880                             ; 
F880   22 B0 24     STMNT:    SHLD   CURENT   ; Save current line number
F883   69                     MOV   L,C   ; Copy BC (?) to HL
F884   60                     MOV   H,B   ; 
F885   22 86 24               SHLD   NUMBR   ; And save it in char ptr
F888   78                     MOV   A,B   ; 16-bits test if BC is zero
F889   B1                     ORA   C   ; 
F88A   C2 11 F9               JNZ   SKP2   ; Skip if line-number <> 0
F88D                             ; 
F88D   2A 8C 24               LHLD   AMPERS   ; Point past end of program
F890   EB                     XCHG      ; Put it in DE
F891   21 40 25               LXI   H,PRGM   ; point to start of user program
F894                             ; 
F894                             ; List (display) program on terminal.
F894                             ; 
F894   CD 69 F8     LST2:     CALL   CPHD   ; Check if next = start (= no program)
F897                             ; 
F897   CA 10 F8               JZ   START   ; Yes: Return to interpreter
F89A                             ; 
F89A   D5                     PUSH   D   ; No:
F89B   4E                     MOV   C,M   ; 
F89C   23                     INX   H   ; Get line number from memory
F89D   46                     MOV   B,M   ;   and put it into BC.
F89E   E5                     PUSH   H   ; Save line-pointer
F89F   CD 9B F9               CALL   PRNT2   ; Print 16-bit line number in decimal
F8A2                             ; 
F8A2   E1                     POP   H   ; Restore line-pointer
F8A3   23                     INX   H   ; Move past line-number content
F8A4   CD C9 F9               CALL   PNTMSG   ; Print contents of line
F8A7                             ; 
F8A7   CD 93 FB               CALL   CRLF   ; End of line
F8AA                             ; 
F8AA   D1                     POP   D   ; 
F8AB   C3 94 F8               JMP   LST2   ; Loop until end of program
F8AE                             ; 
F8AE                             ;--------------------------------
F8AE                             ; Next text?
F8AE                             ; 
F8AE   2A 7E 24     NXTXT:    LHLD   LINPTR   ; Line-pointer
F8B1   23                     INX   H   ; Point past Line-Number
F8B2   23           LOOKAG:   INX   H   ; Find end of line
F8B3   7E                     MOV   A,M   ; 
F8B4   A7                     ANA   A   ; 
F8B5   C2 B2 F8               JNZ   LOOKAG   ; Look again...
F8B8                             ; 
F8B8                             ; Closing-Paren in line also uses those 2 instructions...
F8B8                             ; 
F8B8   23           OUTH:     INX   H   ; And point to next
F8B9   C9                     RET      ; Done
F8BA                             ; 
F8BA                             ;--------------------------------
F8BA                             ; Find line-number
F8BA                             ; 
F8BA   2A 8C 24     FIND:     LHLD   AMPERS   ; Point at first byte of user program
F8BD   4D                     MOV   C,L   ; 
F8BE   44                     MOV   B,H   ; Copy it to BC
F8BF   2A 86 24               LHLD   NUMBR   ; Char ptr
F8C2   EB                     XCHG      ; Copy it to DE
F8C3   21 40 25               LXI   H,PRGM   ; PC of user program
F8C6   22 7E 24     FND2:     SHLD   LINPTR   ; Set it equal to line-pointer
F8C9   7C                     MOV   A,H   ; Get and compare
F8CA   B8                     CMP   B   ; High bytes
F8CB   C2 D1 F8               JNZ   NXTUU   ; Non-zero if high-bytes don't match
F8CE   7D                     MOV   A,L   ; If high bytes match, then compare
F8CF   B9                     CMP   C   ; Low bytes
F8D0   C8                     RZ      ; Zero: Return with no carry, equal
F8D1                             ; 
F8D1                             ; Not zero: ?
F8D1                             ; 
F8D1   7E           NXTUU:    MOV   A,M   ; Get low byte of user program
F8D2   93                     SUB   E   ; Subtract low byte of char ptr
F8D3   23                     INX   H   ; Point to next byte
F8D4   7E                     MOV   A,M   ; Get high byte of user program
F8D5   9A                     SBB   D   ; Subtract low byte of char ptr
F8D6   2B                     DCX   H   ; Point to previous byte
F8D7   3F                     CMC      ; Complement Carry flag
F8D8   D8                     RC      ; Return if DE > M(HL)
F8D9                             ; 
F8D9                             ; Else, find next line
F8D9                             ; 
F8D9   CD AE F8     FND3:     CALL   NXTXT   ; 
F8DC                             ; 
F8DC   C3 C6 F8               JMP   FND2   ; 
F8DF                             ; 
F8DF                             ;--------------------------------
F8DF                             ; 
F8DF                             ;         Subroutine to evaluate line
F8DF                             ; 
F8DF   FE 22        EVIL:     CPI   022h   ; Is it a quote surrounding strings?
F8E1   CA 8B FB               JZ   QUOTE2   ; Yes: go process it
F8E4                             ; 
F8E4   CD 2D FA               CALL   EVAL   ; No: Evaluate expression
F8E7                             ; 
F8E7   C5                     PUSH   B   ; 
F8E8   2A AE 24               LHLD   LINUMB   ; ?
F8EB   CD 0C FB               CALL   CONVP   ; Convert pointer to point to variable
F8EE                             ; 
F8EE   C1                     POP   B   ; Get back pointer to storage
F8EF   FE 24                  CPI   "$"   ; Is it a single character string?
F8F1   C2 F8 F8               JNZ   ANDT   ; No: Go check if it is a "?" char
F8F4                             ; 
F8F4   79                     MOV   A,C   ; Yes:
F8F5   C3 05 FA               JMP   OUTCH   ; Print the character
F8F8                             ; 
F8F8                             ; It is not a single char string. Is it "?" char?
F8F8                             ; 
F8F8   D6 3F        ANDT:     SUI   "?"   ; 
F8FA   CA 9B F9               JZ   PRNT2   ; Yes: print the value in decimal
F8FD                             ; 
F8FD                             ; System Variable "Greater Than" subroutine.
F8FD                             ; 
F8FD                             ; Pass a 16-bits value in BC to a machine language subroutine.
F8FD                             ; 
F8FD                             ; Note: Value from executing line is in BC register.
F8FD                             ; Machine-Language routine can return another value in this
F8FD                             ; Register-pair; and it will be saved in the ">" variable.
F8FD                             ; The Accumulator passed cleared; but can be freely used.
F8FD                             ; All other registers other than the BC and registers *must* be
F8FD                             ; returned unchanged!
F8FD                             ; 
F8FD   3C                     INR   A   ; Is it a ">" char?
F8FE   CC 00 24               CZ   BRKPNT   ; Call RST 0 at 0000H
F901                             ; 
F901                             ; "At the conclusion of the machine language subroutine,
F901                             ; a Intel 8080 RET instruction returns control to VTL-2,
F901                             ; 
F901                             ; The value in B&C is stored in the appropriate variable.
F901                             ; 
F901   71                     MOV   M,C   ; Copy BC to Variable Storage
F902   23                     INX   H   ; 
F903   70                     MOV   M,B   ; 
F904   2A 8E 24               LHLD   QUITE   ; Get Random-number
F907   09                     DAD   B   ; Add current value to random number
F908   22 8E 24               SHLD   QUITE   ; And save new random number
F90B                             ; 
F90B                             ; Compare BC and DE and return with flags
F90B                             ; 
F90B   79           CPBD:     MOV   A,C   ; 
F90C   BB                     CMP   E   ; 
F90D   C0                     RNZ      ; 
F90E   78                     MOV   A,B   ; DE = ?
F90F   BA                     CMP   D   ; 
F910   C9                     RET      ; 
F911                             ; 
F911                             ;--------------------------------
F911                             ; 
F911   CD BA F8     SKP2:     CALL   FIND   ; Find either same line or place for insert
F914                             ; 
F914   D2 36 F9               JNC   INSRT   ; If past end, then insert
F917   CD 65 F8               CALL   LXHN   ; Check if line found is same line
F91A   C2 36 F9               JNZ   INSRT   ; If not, then Insert
F91D   CD AE F8               CALL   NXTXT   ; Else bump past current line
F920                             ; 
F920   EB                     XCHG      ; 
F921   2A 7E 24               LHLD   LINPTR   ; Line-pointer
F924   CD 0B F9     DELT:     CALL   CPBD   ; Compare BC with DE
F927   CA 31 F9               JZ   FITIT   ; Equal: If finished deleting, then continue
F92A   1A                     LDAX   D   ; Move byte at M(DE)
F92B   77                     MOV   M,A   ;   to M(HL).
F92C   23                     INX   H   ; Increment HL
F92D   13                     INX   D   ; Increment DE
F92E   C3 24 F9               JMP   DELT   ; Loop and continue removing line
F931                             ; 
F931                             ; Insert a program line in program "text".
F931                             ; 
F931   22 8C 24     FITIT:    SHLD   AMPERS   ; Save address of new end of user program
F934   44                     MOV   B,H   ; Copy HL to BC
F935   4D                     MOV   C,L   ; 
F936   2A B0 24     INSRT:    LHLD   CURENT   ; Count new line-length
F939   11 03 00               LXI   D,0003H   ; 3 = delimiter (0-byte) + line number
F93C   7E                     MOV   A,M   ; Get byte
F93D   A7                     ANA   A   ; Is it the end-of-line?
F93E   CA 1D F8               JZ   LOOP   ; Yes: Back to main loop of interpreter
F941                             ; 
F941   13           CNTLN:    INX   D   ; No: Calculate new end
F942   23                     INX   H   ; 
F943   7E                     MOV   A,M   ; Get next byte
F944   A7                     ANA   A   ; 
F945   C2 41 F9               JNZ   CNTLN   ; Not zero: Back to main loop of interpreter
F948                             ; 
F948                             ; Zero: ?
F948                             ; 
F948   EB           OPEN:     XCHG      ; 
F949   09                     DAD   B   ; Add BC
F94A   EB                     XCHG      ; Put result in DE
F94B   21 94 24               LXI   H,STAR   ; Memory size
F94E   7B                     MOV   A,E   ; Subtract memory size from program length?
F94F   96                     SUB   M   ; 
F950   23                     INX   H   ; 
F951   7A                     MOV   A,D   ; 
F952   9E                     SBB   M   ; 
F953   D2 10 F8               JNC   START   ; If too big, then stop
F956                             ; 
F956                             ; Some available memory is present.
F956                             ; 
F956   EB                     XCHG      ; 
F957   22 8C 24               SHLD   AMPERS   ; Then, this must be next byte of user PGM?
F95A   03                     INX   B   ; 
F95B   23                     INX   H   ; 
F95C   E5                     PUSH   H   ; 
F95D   2A 7E 24               LHLD   LINPTR   ; Line-pointer
F960   EB                     XCHG      ; 
F961   E1                     POP   H   ; 
F962                             ; 
F962   0B           SLIDE:    DCX   B   ; Slide open gap for new line
F963   2B                     DCX   H   ; 
F964   0A                     LDAX   B   ; A = M(BC)
F965   77                     MOV   M,A   ; 
F966   CD 0B F9               CALL   CPBD   ; Until space is made for new one
F969   C2 62 F9               JNZ   SLIDE   ; Move program above new line up.
F96C                             ; 
F96C   2A 86 24     DON:      LHLD   NUMBR   ; Char ptr
F96F   7D                     MOV   A,L   ; Get M(HL)
F970   02                     STAX   B   ; M(BC) = A
F971   03                     INX   B   ; Increment BC
F972   7C                     MOV   A,H   ; Get M(HL)
F973   02                     STAX   B   ; M(BC) = A  Save new line-number in program
F974   2A B0 24               LHLD   CURENT   ; Point at line-buffer
F977                             ; 
F977   03           MOVL:     INX   B   ; Move line from line-buffer to program
F978   7E                     MOV   A,M   ; 
F979   02                     STAX   B   ; M(BC) = A
F97A   23                     INX   H   ; 
F97B   A7                     ANA   A   ; 
F97C   C2 77 F9               JNZ   MOVL   ; Until end-of-line in line-buffer
F97F   C3 1D F8               JMP   LOOP   ; Back to main loop of interpreter
F982                             ; 
F982                             ;--------------------------------
F982                             ;       I/O subroutines
F982                             ;--------------------------------
F982                             ; The following routines:
F982                             ; INCH   or Input-Character  from Terminal
F982                             ; OUTCH  or Output-Character   to Terminal
F982                             ; POLCAT or Poll-For-Character on Terminal
F982                             ; are each repeated 4 times, once for each I/O port.
F982                             ; The POLSNS routine is used to check which of the
F982                             ; four following routines to execute; depending on the
F982                             ; Terminal settings in the sense-switches.
F982                             ; 
F982                             ; The INCH and OUTCH routines both use the common
F982                             ; routine: POLCAT to see if a character is ready
F982                             ; for input or output on the selected terminal.
F982                             ;--------------------------------
F982                             ; 
F982                             ; 
F982                             ; Poll for character at terminal
F982                             ; Status returns carry-flag set if input character available
F982                             ; Status returns non-zero if output is ready for character
F982                             ; 
F982                          IF   MACHINE = 1   
                                 ; 
                                 ; 8250 UART of AL80
                                 ; 
                    POLCAT:   IN   UART5   ; I/O Port-0 = Single-SIO board
                              ANI   021H   ; bit0 = RX data available, bit5 TX empty
                              RAR      ; TBE bit to bit-4; RDA bit to carry
                              RNC      ; Zero and carry status right if low
                              ANA   A   ; Else check new shifted output bit
                              STC      ; And set the carry
                              RET      ; Return with status
F982                          ELSE      ; Z80 SIO/0
F982                             ; 
F982                             ; SIO/0 UART of MintZ80
F982                             ; 
F982   C5           POLCAT:   PUSH   b   
F983   3E 01                  MVI   a,1   ; select RR1
F985   D3 19                  OUT   SIO_CA   
F987   DB 19                  IN   SIO_CA   
F989   E6 01                  ANI   001h   ; 7c bit 0 is TX ready
F98B   17                     RAL      ; rotate to bit 1
F98C   47                     MOV   b,a   ; save in reg B
F98D   97                     SUB   a   ; 4c clear a, write into WR0: select RR0
F98E   D3 19                  OUT   SIO_CA   ; 11c
F990   DB 19                  IN   SIO_CA   ; 11c read RRx
F992   E6 01                  ANI   001h   ; 7c bit 0 is RX ready
F994   B0                     ORA   b   
F995   C1                     POP   b   
F996   1F                     RAR      ; TBE bit to bit-4; RDA bit to carry
F997   D0                     RNC      ; Zero and carry status right if low
F998   A7                     ANA   A   ; Else check new shifted output bit
F999   37                     STC      ; And set the carry
F99A   C9                     RET      ; Return with status
F99B                          ENDIF      
F99B                             ; 
F99B                             ;--------------------------------
F99B                             ; Print 16-bit line number in decimal.
F99B                             ; 
F99B                             ; On Entry, BC = Number to be printed
F99B                             ; 
F99B                             ; On exit, all registers are used and changed
F99B                             ; 
F99B   11 BD 24     PRNT2:    LXI   D,DECBUF-1   ; Decimal buffer (5 chars long)
F99E   21 21 FB               LXI   H,PWRS10   ; Table of decimal values
F9A1   13           CVD1:     INX   D   ; To save program space, do incr here
F9A2   D5                     PUSH   D   ; Save address of next character-space
F9A3   50                     MOV   D,B   ; Copy Number (or remainder of it) to DE
F9A4   59                     MOV   E,C   ; For upcoming divide
F9A5   4E                     MOV   C,M   ; Get Decimal divider in BC
F9A6   23                     INX   H   ; 
F9A7   46                     MOV   B,M   ; 
F9A8   23                     INX   H   ; Then point to next decimal divisor
F9A9   E5                     PUSH   H   ; Save address current divisor
F9AA                             ; 			  BC: divisor, DE: dividend
F9AA   CD 8A FA               CALL   DIV   ; Divide by 10,000, 1000, 100, 10, 1
F9AD                             ; 			  DE: quotient, HL: remainder
F9AD   7B                     MOV   A,E   ; Temp save result of divide in A
F9AE   44                     MOV   B,H   ; Copy remainder to BC for next divide
F9AF   4D                     MOV   C,L   ; 
F9B0   E1                     POP   H   ; Restore address of next divisor to HL
F9B1   D1                     POP   D   ; Restore address of where to store char.
F9B2   C6 30                  ADI   "0"   ; Make result of divide an ASCII number
F9B4   12                     STAX   D   ; Store new decimal character
F9B5   7B                     MOV   A,E   ; Get pointer byte
F9B6   FE C2                  CPI   lsb(LASTD)   ; See if at end of number
F9B8   DA A1 F9               JC   CVD1   ; If not past table, then continue.
F9BB                             ; 
F9BB                             ; Suppress zeroes.
F9BB                             ; 
F9BB   1A                     LDAX   D   ; Get last digit
F9BC   F6 80                  ORI   10000000B   ; Add high-bit so 0 gets printed
F9BE   12                     STAX   D   ; Save last digit with high-bit set
F9BF   21 BD 24               LXI   H,DECBUF-1   ; Point before decimal buffer
F9C2   23           ZRSUP:    INX   H   ; Point to next char
F9C3   7E                     MOV   A,M   ; Get it
F9C4   FE 30                  CPI   "0"   ; Is it an ASCII zero?
F9C6   CA C2 F9               JZ   ZRSUP   ; Yes: Loop, not showing zeroes
F9C9                             ; 
F9C9                             ; Print message -- Init delimiter to zero.
F9C9                             ; 
F9C9   AF           PNTMSG:   XRA   A   ; Init delimiter to zero
F9CA                             ; 
F9CA                             ; Print a message.
F9CA                             ; Delimiter is in A.  (Might be 0 byte or quote.)
F9CA                             ; 
F9CA   47           STRMSG:   MOV   B,A   ; and put it in B-reg.
F9CB   7E           OUTMSG:   MOV   A,M   ; Get char from memory
F9CC   23                     INX   H   ; Update memory pointer
F9CD   B8                     CMP   B   ; Is it the delimiter?
F9CE   CA D7 F9               JZ   CONTC   ; Yes: Check if it is Ctrl-C
F9D1   CD 03 FA               CALL   ASCII   ; No: Display the char on the terminal
F9D4   C3 CB F9               JMP   OUTMSG   ; and loop until delimiter found.
F9D7                             ; 
F9D7                             ; Check for Control-C.
F9D7                             ; 
F9D7   CD 82 F9     CONTC:    CALL   POLCAT   ; Poll character at terminal?
F9DA   D0                     RNC      ; None available: Return
F9DB   CD E3 F9               CALL   INCH   ; One char present: Get it
F9DE   FE 03                  CPI   CTRLC   ; Is it Control-C?
F9E0   CA 10 F8               JZ   START   ; Yes: Return to interpreter
F9E3                             ; No: Get char (Implement Pause)
F9E3                             ; 
F9E3                             ; 
F9E3                             ; Input a character, whatever the I/O ports involved.
F9E3                             ; 
F9E3   CD 82 F9     INCH:     CALL   POLCAT   ; Check status for character input
F9E6   DA FE F9               JC   INA   ; One available: Go process it
F9E9                             ; 
F9E9                             ; Status was FALSE: There is no char in one of the I/O
F9E9                             ; ports, so let's check the Cassette tape player, instead.
F9E9                             ; 
F9E9   3A 9C 24               LDA   PERIOD   ; Terminal/Cassette echo switch
F9EC   E6 02                  ANI   0010B   
F9EE                             ;		 |||
F9EE                             ;		 ||+--> 0 = Nothing displayed on terminal
F9EE                             ;		 ||     1 = Chars.  displayed on terminal
F9EE                             ;		 |+---> 2 = Input from Cassette
F9EE                             ;		 +----> 4 = Output  to Cassette
F9EE                             ; 
F9EE   CA E3 F9               JZ   INCH   ; No cassete input wanted; so loop
F9F1                             ; 
F9F1                             ; No: Input from cassette
F9F1                             ; 
F9F1   DB 06                  IN   CASSTS   ; I/O port 6 = Cassette Status
F9F3   0F                     RRC      ; Check if character ready yet
F9F4   DA E3 F9               JC   INCH   ; Loop while waiting for char
F9F7   DB 07                  IN   CASSTD   ; I/O port 7 = cassette Data
F9F9   E6 7F                  ANI   01111111B   ; Strip off upper bit
F9FB   C3 1B FA               JMP   OUTCAS   ; Don't echo to Cassete from Cassette
F9FE                             ; 
F9FE                             ; Status was TRUE: There is a char in one of the I/O ports.
F9FE                             ; 
F9FE                          IF   MACHINE = 1   
                    INA:      IN   UART0   ; I/O port  1 = Single-SIO Data
F9FE                          ELSE   if MACHINE = 2   
F9FE   DB 18        INA:      IN   SIO_DA   ; I/O port  1 = Single-SIO Data
FA00                          ENDIF      
FA00   C3 03 FA               JMP   ASCII   ; 
FA03                             ; 
FA03   E6 7F        ASCII:    ANI   01111111B   ; Strip off upper bit
FA05                             ; 
FA05                             ; Fall through to the "output char" subroutine.
FA05                             ; 
FA05                             ; For all the checking of terminal options and cassete-I/O.
FA05                             ; The OUTCH or Output-Character routine doesn't change
FA05                             ; ANY registers except the stack; returning to the calling
FA05                             ; routine with all registers unchanged.
FA05                             ; 
FA05   F5           OUTCH:    PUSH   PSW   ; Save char to check if cassette echo
FA06   3A 9C 24               LDA   PERIOD   ; Terminal/Cassette echo switch
FA09   E6 04                  ANI   0100B   
FA0B                             ;		 |||
FA0B                             ;		 ||+--> 0 = Nothing displayed on terminal
FA0B                             ;		 ||     1 = Chars.  displayed on terminal
FA0B                             ;		 |+---> 2 = Input from Cassette
FA0B                             ;		 +----> 4 = Output  to Cassette
FA0B                             ; 
FA0B   CA 1C FA               JZ   OUTA   ; Skip if don't want Cassette output
FA0E                             ; 
FA0E                             ; No: Save on cassette.
FA0E                             ; 
FA0E   DB 06        OUTC:     IN   CASSTS   ; I/O port 6 = cassette Status
FA10   3C                     INR   A   ; Check if exists
FA11   CA 1C FA               JZ   OUTA   ; If not, then skip Cassette output
FA14   07                     RLC      ; Check Cassette status
FA15   DA 0E FA               JC   OUTC   ; Loop while waiting for char
FA18   F1                     POP   PSW   ; Restore char
FA19   D3 07                  OUT   CASSTD   ; I/O port 7 = cassette Data
FA1B   F5           OUTCAS:   PUSH   PSW   ; And then save it again
FA1C                             ; 
FA1C                             ; Now, determine on which terminal to display the char.
FA1C                             ; 
FA1C   3A 9C 24     OUTA:     LDA   PERIOD   ; Terminal/Cassette echo switch
FA1F   0F                     RRC      ; Test Terminal echo bit
FA20                             ;               0001B
FA20                             ;		 |||
FA20                             ;		 ||+--> 0 = Nothing displayed on terminal
FA20                             ;		 ||     1 = Chars.  displayed on terminal
FA20                             ;		 |+---> 2 = Input from Cassette
FA20                             ;		 +----> 4 = Output  to Cassette
FA20                             ; 
FA20   D2 1F FB               JNC   OUTD   ; No terminal output wanted; so skip
FA23   CD 82 F9     OUTB:     CALL   POLCAT   ; Check if ready for output
FA26   CA 23 FA               JZ   OUTB   ; Wait until ready
FA29   F1                     POP   PSW   ; Get character back
FA2A                          IF   MACHINE = 1   
                              OUT   UART0   ; I/O port 1 = Single-SIO board Data
FA2A                          ELSE      
FA2A   D3 18                  OUT   SIO_DA   ; I/O port 1 = Single-SIO board Data
FA2C                          ENDIF      
FA2C   C9                     RET      ; Done
FA2D                             ; 
FA2D                             ;--------------------------------
FA2D                             ; Evaluate expressions
FA2D                             ; 
FA2D                             ; HL = Pointer to expression to be evaluated.
FA2D                             ; A zero-byte (end-of-line) or right-paren ")"
FA2D                             ; Ends evaluation.
FA2D                             ; The right-paren can be start of a comment
FA2D                             ; or the end of a parenthesized expression
FA2D                             ; or the end of an array definition
FA2D                             ; 
FA2D   CD CC FA     EVAL:     CALL   GETVAL   ; Get value of a number
FA30                             ; 
FA30                             ; Next term of an expression
FA30                             ; HL = Pointer to current position in line
FA30                             ; BC = Current value as expressed so far
FA30                             ; 
FA30   7E           NXTRM:    MOV   A,M   ; 
FA31   A7                     ANA   A   ; End-of-line?
FA32   C8                     RZ      ; Yes: Return
FA33   FE 29                  CPI   ")"   ; No: Is it a closing parenthesis?
FA35   CA B8 F8               JZ   OUTH   ; Yes: INC HL past paren and return
FA38   CD 43 FA               CALL   TERM   ; No: Process term of expression
FA3B   44                     MOV   B,H   ; Copy result of expression to BC
FA3C   4D                     MOV   C,L   ; 
FA3D   2A A0 24               LHLD   EVALPT   ; Load eval pointer
FA40   C3 30 FA               JMP   NXTRM   ; and loop until end of terms found.
FA43                             ; 
FA43                             ;--------------------------------
FA43                             ; Process one term of an arithmetic expression.
FA43                             ; 
FA43                             ; BC always comes in with last value
FA43                             ; HL points to next operator
FA43                             ; Character after operator is next value to be operted on
FA43                             ; HL always returns with value of term as effected by operator
FA43                             ; 
FA43   C5           TERM:     PUSH   B   ; Save present-value on Stack
FA44   7E                     MOV   A,M   ; Get operator
FA45   F5                     PUSH   PSW   ; Save operator on stack
FA46   23                     INX   H   ; Point to next value to be worked with
FA47   CD CC FA               CALL   GETVAL   ; Get value of next number or variable
FA4A                             ;			  New value returns in BC
FA4A   22 A0 24               SHLD   EVALPT   ; Save save current position in line
FA4D   F1                     POP   PSW   ; Restore operator for testing
FA4E   E1                     POP   H   ; Place old value in HL
FA4F                             ; 
FA4F                             ; Is it addition?
FA4F                             ; 
FA4F   FE 2B                  CPI   "+"   ; Addition?
FA51   C2 56 FA               JNZ   EVAL2   ; No: Check next arithmetic operation
FA54                             ; 
FA54                             ; Yes: 16-bit addition.
FA54                             ; 
FA54   09                     DAD   B   ; Add BC to HL
FA55   C9                     RET      ; Result in HL
FA56                             ; 
FA56                             ;--------------------------------
FA56                             ; Is it subtraction?
FA56                             ; 
FA56   FE 2D        EVAL2:    CPI   "-"   ; Subtraction?
FA58   C2 62 FA               JNZ   EVAL3   ; No: Check next arithmetic operation
FA5B                             ; 
FA5B                             ; Yes: 16-bit subtraction subroutine.
FA5B                             ; 
FA5B   7D           HSUBB:    MOV   A,L   ; Subtract BC from HL
FA5C   91                     SUB   C   ; 
FA5D   6F                     MOV   L,A   ; 
FA5E   7C                     MOV   A,H   ; 
FA5F   98                     SBB   B   ; 
FA60   67                     MOV   H,A   ; 
FA61   C9                     RET      ; Result in HL Carry in flags
FA62                             ; 
FA62                             ;--------------------------------
FA62                             ; Is it multiplication?
FA62                             ; 
FA62   FE 2A        EVAL3:    CPI   "*"   ; 
FA64   C2 7C FA               JNZ   EVAL4   ; No: Check next arithmetic operation
FA67                             ; 
FA67                             ; Yes: 16-bit multiplication subroutine.
FA67                             ; 
FA67   EB                     XCHG      ; Put multiplicand in DE
FA68   21 00 00               LXI   H,0000H   ; Clear partial product
FA6B   3E 10                  MVI   A,10H   ; Set loop count to 16 bits
FA6D   F5           MULT1:    PUSH   PSW   ; Save it on Stack
FA6E   29                     DAD   H   ; Add to product
FA6F   EB                     XCHG      ; Put it into DE
FA70   29                     DAD   H   ; Add to product
FA71   EB                     XCHG      ; Put it into HL
FA72   D2 76 FA               JNC   MULT2   ; If the result has 17 bits,
FA75                             ; 
FA75   09                     DAD   B   ;   add multiplier to product.
FA76   F1           MULT2:    POP   PSW   ; Restore count
FA77   3D                     DCR   A   ; Decrement it
FA78   C2 6D FA               JNZ   MULT1   ; Not end: Loop
FA7B                             ; 
FA7B   C9                     RET      ; Result in HL
FA7C                             ; 
FA7C                             ;--------------------------------
FA7C                             ; Is it division?
FA7C                             ; 
FA7C   FE 2F        EVAL4:    CPI   "/"   ; Division?
FA7E   C2 A9 FA               JNZ   EVAL5   ; No: Now, check relational operators
FA81                             ; 
FA81   EB                     XCHG      ; Swap current number into dividend
FA82   CD 8A FA               CALL   DIV   ; Yes: Use division subroutine
FA85   22 8A 24               SHLD   PERCNT   ; Save remainder of divide operation
FA88   EB                     XCHG      ; 
FA89   C9                     RET      ; Result in HL
FA8A                             ; 
FA8A                             ;--------------------------------
FA8A                             ; 16-bit division subroutine.
FA8A                             ; 
FA8A                             ; On entry:
FA8A                             ; BC: divisor, DE: dividend
FA8A                             ; On return:
FA8A                             ; BC: divisor, DE: quotient, HL: remainder
FA8A                             ; 
FA8A                             ; The divide routine shifs the dividend left 16 bits
FA8A                             ; A bit at a time into the remainder
FA8A                             ; With each shift-left (*2) the divisor is subtracted;
FA8A                             ; and if a good subtract, a new bit for the quotient
FA8A                             ; is put in the result.
FA8A                             ; 
FA8A   21 00 00     DIV:      LXI   H,0000H   ; Initialize remainder in HL
FA8D   78                     MOV   A,B   ; Checks if 16-bit divisor = zero
FA8E   B1                     ORA   C   ; 
FA8F   3E 10                  MVI   A,16   ; Set loop count to 16 bits
FA91   C8           DIV1:     RZ      ; Yes: Return (division by zero is forbidden)
FA92   F5                     PUSH   PSW   ; Save loop-count on Stack
FA93   29                     DAD   H   ; Remainder * 2 Since dividend will be shifted
FA94   EB                     XCHG      ; 
FA95   29                     DAD   H   ; And dividend * 2
FA96   EB                     XCHG      ; 
FA97   D2 9B FA               JNC   DIV2   ; Shift high-bit from dividend into remainder
FA9A   23                     INX   H   ; 
FA9B   CD 5B FA     DIV2:     CALL   HSUBB   ; Subtract Divisor from Current remainder
FA9E   13                     INX   D   ; If good subtract, then shift bit to quotient
FA9F   D2 A4 FA               JNC   DIV3   ; And continue if good
FAA2   09                     DAD   B   ; Else add subtracted number back
FAA3   1B                     DCX   D   ; And remove shifted-in bit
FAA4   F1           DIV3:     POP   PSW   ; Restore loop count
FAA5   3D                     DCR   A   ; Decrement it
FAA6   C3 91 FA               JMP   DIV1   ; Not end: Loop
FAA9                             ; 
FAA9                             ;--------------------------------
FAA9                             ; Now, check the relational operators.
FAA9                             ; 
FAA9   EB           EVAL5:    XCHG      ; Move old-value to DE for tests
FAAA   21 00 00               LXI   H,0000H   ; Init HL with FALSE value
FAAD                             ; 
FAAD                             ;--------------------------------
FAAD                             ; Is it equality-test?
FAAD                             ; 
FAAD   D6 3D        EVIL5:    SUI   "="   ; 
FAAF   C2 BA FA               JNZ   EVIL6   ; No: Check next relational operators
FAB2                             ; 
FAB2   7A                     MOV   A,D   ; Get low byte
FAB3   B8                     CMP   B   ; And check with high-byte
FAB4   C0                     RNZ      ; Return if value not zero
FAB5   7B                     MOV   A,E   ; Get low byte
FAB6   B9                     CMP   C   ; And check with high-byte
FAB7   C0                     RNZ      ; Return if value not zero
FAB8   23                     INX   H   ; Yes: = 1 (TRUE value)
FAB9   C9                     RET      ; 
FABA                             ; 
FABA                             ;--------------------------------
FABA                             ; Is it greater-than-or-equals test?
FABA                             ; 
FABA   3D           EVIL6:    DCR   A   ; "=" - 1 = "<"
FABB   CA C5 FA               JZ   EVIL7   ; Yes: Check relational operator
FABE                             ; 
FABE                             ; Default is less-than test.
FABE                             ; 
FABE   7B                     MOV   A,E   ; Subtract BC from DE
FABF   91                     SUB   C   ; 
FAC0   7A                     MOV   A,D   ; 
FAC1   98                     SBB   B   ; 
FAC2   D0                     RNC      ; Return if test is FALSE
FAC3   23                     INX   H   ; = 1 (TRUE value)
FAC4   C9                     RET      ; 
FAC5                             ; 
FAC5                             ;--------------------------------
FAC5                             ; Test for greater-than-or-equals
FAC5                             ; 
FAC5   7B           EVIL7:    MOV   A,E   ; Subtract BC from DE
FAC6   91                     SUB   C   ; 
FAC7   7A                     MOV   A,D   ; 
FAC8   98                     SBB   B   ; 
FAC9   D8                     RC      ; Return if test is FALSE
FACA   23                     INX   H   ; = 1 (TRUE value)
FACB   C9                     RET      ; 
FACC                             ; 
FACC                             ;--------------------------------
FACC                             ; Get next value
FACC                             ; 
FACC                             ; HL = Pointer to variable or other to be evaluated.
FACC                             ; BC returns value
FACC                             ; 
FACC   CD 36 FB     GETVAL:   CALL   CVBIN   ; Convert to binary number
FACF                             ; 
FACF   D0                     RNC      ; It was a number: Done
FAD0                             ; 
FAD0   FE 3F                  CPI   "?"   ; Is it a PRINT statement?
FAD2   23                     INX   H   ; Increment mem ptr past ?
FAD3   C2 E3 FA               JNZ   VAR   ; No: Check if it is a variable name
FAD6                             ; 
FAD6                             ; Yes: ?
FAD6                             ; 
FAD6   22 B2 24               SHLD   VALVAR   ; Save value of variable?
FAD9   CD 68 FB               CALL   INLN   ; Get line from operator
FADC                             ; 
FADC   CD 2D FA               CALL   EVAL   ; Evaluate line
FADF   2A B2 24               LHLD   VALVAR   ; Return value of line operator enters
FAE2   C9                     RET      ; 
FAE3                             ; 
FAE3                             ;--------------------------------
FAE3                             ; Is it a variable name?
FAE3                             ; 
FAE3                             ; BC: ?, DE: ?, HL: ?
FAE3                             ; 
FAE3   FE 24        VAR:      CPI   "$"   ; Is it an String-INPUT statement?
FAE5   C2 EF FA               JNZ   VAR1   ; No: Check next possibility
FAE8                             ; 
FAE8   CD E3 F9               CALL   INCH   ; Yes: Input next char
FAEB                             ; 
FAEB   4F                     MOV   C,A   ; 
FAEC   06 00                  MVI   B,00H   ; Make sure a char is a byte value
FAEE   C9                     RET      ; 
FAEF                             ; 
FAEF                             ; Is it the start of an expression?
FAEF                             ; 
FAEF   FE 28        VAR1:     CPI   "("   ; If left-paren, then
FAF1   CA 2D FA               JZ   EVAL   ; Evaluate whole expression
FAF4                             ; 
FAF4   2B                     DCX   H   ; No: Re-point to character
FAF5                             ; 
FAF5   CD 0C FB     VAR2:     CALL   CONVP   ; Get line and convert to value
FAF8                             ; 
FAF8   4E                     MOV   C,M   ; 
FAF9   23                     INX   H   ; 
FAFA   46                     MOV   B,M   ; 
FAFB   2A AC 24               LHLD   RESULT   ; ?
FAFE   C9                     RET      ; 
FAFF                             ; 
FAFF                             ;--------------------------------
FAFF                             ; Obviously, deal with array DEEK/DOKE...
FAFF                             ; 
FAFF   CD 2D FA     ARRAY:    CALL   EVAL   ; Evaluate expression to find which element
FB02                             ; 
FB02   22 AC 24               SHLD   RESULT   ; Save result of evaluation?
FB05   2A 8C 24               LHLD   AMPERS   ; Get address of next byte of user program
FB08   09                     DAD   B   ; 
FB09   09                     DAD   B   ; Two bytes for every element in array
FB0A   F1                     POP   PSW   ; 
FB0B   C9                     RET      ; Return with pointer to array in HL
FB0C                             ; 
FB0C                             ;--------------------------------
FB0C                             ; Convert character to pointer to memory
FB0C                             ; HL returns with pointer to value
FB0C                             ; 
FB0C   7E           CONVP:    MOV   A,M   ; Get variable letter
FB0D   23                     INX   H   ; 
FB0E   F5                     PUSH   PSW   ; 
FB0F   FE 3A                  CPI   ":"   ; Is it the start of an array statement?
FB11   CA FF FA               JZ   ARRAY   ; Yes: Go to ARRAY subroutine
FB14                             ; 
FB14                             ; All characters map as:
FB14                             ; "@" to "_" as 00H to 1FH (Includes "A" to "Z")
FB14                             ; " " to "?" as 20H to 3FH (Includes "0" to "9")
FB14                             ; Note inversion!
FB14                             ; "@" maps BEFORE space not after it
FB14                             ; 
FB14   22 AC 24               SHLD   RESULT   ; Save value of expression
FB17   E6 3F                  ANI   00111111B   ; = 3FH (Uppercase Only)
FB19   21 20 12               LXI   H,AT/2   ; We're going to double this, so ....
FB1C   85                     ADD   L   ; Add Character offset into var table
FB1D   6F                     MOV   L,A   ; Calculate standard letter variables
FB1E   29                     DAD   H   ; 2 bytes for each variable
FB1F                             ; 
FB1F                             ; "Output a char" also uses those 2 instructions...
FB1F                             ; 
FB1F   F1           OUTD:     POP   PSW   ; Restore accumulator
FB20   C9                     RET      ; 
FB21                             ; 
FB21                             ;--------------------------------
FB21                             ; Table of powers of 10.
FB21                             ; 
FB21   10 27        PWRS10:   DW   10000   
FB23   E8 03                  DW   1000   
FB25   64 00                  DW   100   
FB27   0A 00                  DW   10   
FB29   01 00                  DW   1   
FB2B                             ; 
FB2B                             ;--------------------------------
FB2B                             ; Test if character is an ASCII numeric
FB2B                             ; 
FB2B   7E           TSTN:     MOV   A,M   ; Get char
FB2C   FE 3A                  CPI   "9"+1   ; Is it > "9" ?
FB2E   3F                     CMC      ; 
FB2F   D8                     RC      ; 
FB30   FE 30                  CPI   "0"   ; Is it < "0" ?
FB32   C9                     RET      ; 
FB33                             ; 
FB33                             ;--------------------------------
FB33                             ; Get line and convert it to a value
FB33                             ; 
FB33   CD 68 FB     CVTLN:    CALL   INLN   ; 
FB36                             ; 
FB36                             ; Convert to binary number.
FB36                             ; If non-numeric, then carry set and character is in A
FB36                             ; If numeric, then carry clear, and value returned in BC
FB36                             ; 
FB36   CD 2B FB     CVBIN:    CALL   TSTN   ; Is it a number?
FB39   D8                     RC      ; No: Return
FB3A                             ; 
FB3A                             ; Yes: Convert the ASCII char to binary number.
FB3A                             ; 
FB3A   01 00 00               LXI   B,0000H   ; Clear initial value in BC
FB3D   7E           CBLOOP:   MOV   A,M   ; Get next numeric char
FB3E   D6 30                  SUI   "0"   ; Convert from ASCII to binary
FB40   81                     ADD   C   ; Add to value already in BC
FB41   4F                     MOV   C,A   ; 
FB42   3E 00                  MVI   A,00H   ; 
FB44   88                     ADC   B   ; 
FB45   47                     MOV   B,A   ; 
FB46   23                     INX   H   ; Point to next char
FB47   CD 2B FB               CALL   TSTN   ; Is it a number?
FB4A   3F                     CMC      ; 
FB4B   D0                     RNC      ; No: Return with value in BC and Carry cleared
FB4C                             ; 
FB4C                             ; Yes: multiply old number in BC by ten to put new number in
FB4C                             ; 
FB4C   E5                     PUSH   H   ; Save pointer
FB4D   60                     MOV   H,B   ; Copy BC to HL
FB4E   69                     MOV   L,C   ; 
FB4F   29                     DAD   H   ; HL = BC times 2
FB50   29                     DAD   H   ; HL = BC times 4
FB51   09                     DAD   B   ; HL = BC times 5
FB52   29                     DAD   H   ; HL = BC times 10
FB53   44                     MOV   B,H   ; Move result back to BC
FB54   4D                     MOV   C,L   ; 
FB55   E1                     POP   H   ; Restore pointer
FB56   C3 3D FB               JMP   CBLOOP   ; Loop until not a number
FB59                             ; 
FB59                             ;--------------------------------
FB59                             ; Process line input from terminal.
FB59                             ; 
FB59   FE 40        INLN6:    CPI   "@"   ; Discard line inputted?
FB5B   CA 65 FB               JZ   NEWLIN   ; Yes: Start a new line
FB5E                             ; 
FB5E                             ; No: We are in a line. Are we at the end?
FB5E                             ; 
FB5E   23                     INX   H   ; Increment line pointer
FB5F   7D                     MOV   A,L   ; Get its low byte
FB60   FE 0C                  CPI   lsb(LINBUF+72)   ; Are we at the end of the line?
FB62   C2 72 FB               JNZ   INLN2   ; No: Get next char
FB65                             ; 
FB65                             ; Yes: Start a new line on the terminal.
FB65                             ; 
FB65   CD 93 FB     NEWLIN:   CALL   CRLF   ; Return "cursor" at beginning of next line
FB68                             ; 
FB68                             ;         Subroutine __________________________
FB68                             ; 
FB68   21 C5 24     INLN:     LXI   H,LINBUF+1   ; Point to first char in line buffer
FB6B                             ; 
FB6B                             ; Check if we reached the beginning of the line,
FB6B                             ; that is to say: erased all the line, backspacing chars.
FB6B                             ; 
FB6B   2B           INLN5:    DCX   H   ; Point before the first char
FB6C   7D                     MOV   A,L   ; 
FB6D   FE C3                  CPI   lsb(LINBUF-1)   ; Is it the beginning of the line?
FB6F   CA 65 FB               JZ   NEWLIN   ; Yes: Start a new line
FB72                             ; 
FB72                             ; Not at end of line: Get another char, and check it.
FB72                             ; 
FB72   CD E3 F9     INLN2:    CALL   INCH   ; Input another char
FB75                             ; 
FB75   77                     MOV   M,A   ; Sve it in line
FB76   FE 5F                  CPI   "_"   ; Backspace to erase a char?
FB78   CA 6B FB               JZ   INLN5   ; Yes: Check if we erased everything
FB7B                             ; 
FB7B                             ; No: Check if the user had ended inputting a line.
FB7B                             ; 
FB7B   FE 0D        INLN3:    CPI   CR   ; 
FB7D   DA 72 FB               JC   INLN2   ; No: Get another char
FB80                             ; 
FB80   C2 59 FB               JNZ   INLN6   ; Yes: Go proceed another line
FB83                             ; 
FB83   AF           INLN4:    XRA   A   ; Mark end of line with a 00H
FB84   77                     MOV   M,A   ; 
FB85   21 C4 24               LXI   H,LINBUF   ; Point back to beginning of line
FB88   C3 98 FB               JMP   PRLF   ; It was CR: add LF and done
FB8B                             ; 
FB8B                             ;--------------------------------
FB8B                             ; 
FB8B   23           QUOTE2:   INX   H   ; Skip beginning quote
FB8C                             ; 
FB8C                             ;         Subroutine __________________________
FB8C                             ; 
FB8C   CD CA F9     STRNG:    CALL   STRMSG   ; Print string
FB8F   7E                     MOV   A,M   ; Get char *after* delimiter
FB90   FE 3B                  CPI   ";"   ; Is it a semicolon?
FB92   C8                     RZ      ; Yes: Then, no CR/LF after PRINT
FB93                             ; 
FB93                             ; No: End of line reached, output CR and LF.
FB93                             ; 
FB93   3E 0D        CRLF:     MVI   A,CR   ; Carriage-Return
FB95   CD 05 FA               CALL   OUTCH   ; 
FB98   3E 0A        PRLF:     MVI   A,LF   ; Line-Feed
FB9A   CD 05 FA               CALL   OUTCH   ; 
FB9D                             ; 
FB9D                             ;	System Variable COMMA subroutine.
FB9D                             ; 
FB9D                             ; Outputs the number of null bytes (00H) stored in COMMA,
FB9D                             ; while the printhead of the ASR-33 Teletype returns to
FB9D                             ; the left side of the roll of punched paper.
FB9D                             ; 
FB9D   3A 98 24               LDA   COMMA   ; Number of null bytes after cr/lf
FBA0   3D           NULL:     DCR   A   ; Number should be less than 128
FBA1   F8                     RM      ; Return if no more nulls wanted
FBA2   F5                     PUSH   PSW   ; 
FBA3   AF                     XRA   A   ; = Null byte in A-reg
FBA4   CD 05 FA               CALL   OUTCH   ; 
FBA7   F1                     POP   PSW   ; 
FBA8   C3 A0 FB               JMP   NULL   ; Loop the number of null bytes
FBAB                             ; 
FBAB                             ;--------------------------------
FBAB                             ; 
FBAB   0D 0A 4F 4B 00 OKM:    DB   CR,LF,"OK",00H   
FBB0                             ; 
FBB0                             ;--------------------------------
FBB0                             ; 
FBB0                          END      


MACHINE:            0002 DEFINED AT LINE 2
OFFSET:             2400 DEFINED AT LINE 4
                    > USED AT LINE 93
                    > USED AT LINE 153
CASSTS:             0006 DEFINED AT LINE 14
                    > USED AT LINE 653
                    > USED AT LINE 691
CASSTD:             0007 DEFINED AT LINE 15
                    > USED AT LINE 656
                    > USED AT LINE 697
UART_BASE:          0008 DEFINED AT LINE 17
                    > USED AT LINE 18
                    > USED AT LINE 19
                    > USED AT LINE 20
                    > USED AT LINE 21
                    > USED AT LINE 22
                    > USED AT LINE 23
                    > USED AT LINE 24
                    > USED AT LINE 25
UART0:              0008 DEFINED AT LINE 18
UART1:              0009 DEFINED AT LINE 19
UART2:              000A DEFINED AT LINE 20
UART3:              000B DEFINED AT LINE 21
UART4:              000C DEFINED AT LINE 22
UART5:              000D DEFINED AT LINE 23
UART6:              000E DEFINED AT LINE 24
UART7:              000F DEFINED AT LINE 25
SIO_BASE:           0018 DEFINED AT LINE 27
                    > USED AT LINE 28
                    > USED AT LINE 29
                    > USED AT LINE 30
                    > USED AT LINE 31
SIO_DA:             0018 DEFINED AT LINE 28
                    > USED AT LINE 665
                    > USED AT LINE 718
SIO_CA:             0019 DEFINED AT LINE 29
                    > USED AT LINE 545
                    > USED AT LINE 546
                    > USED AT LINE 552
                    > USED AT LINE 553
SIO_DB:             001A DEFINED AT LINE 30
SIO_CB:             001B DEFINED AT LINE 31
CLEAR:              0001 DEFINED AT LINE 78
                    > USED AT LINE 168
INTCI:              0011 DEFINED AT LINE 79
CTRLC:              0003 DEFINED AT LINE 84
                    > USED AT LINE 628
LF:                 000A DEFINED AT LINE 85
                    > USED AT LINE 1130
                    > USED AT LINE 1150
CR:                 000D DEFINED AT LINE 86
                    > USED AT LINE 1105
                    > USED AT LINE 1128
                    > USED AT LINE 1150
BRKPNT:             2400 DEFINED AT LINE 94
                    > USED AT LINE 400
RST0:               2400 DEFINED AT LINE 95
RST1:               2408 DEFINED AT LINE 96
RST2:               2410 DEFINED AT LINE 97
RST3:               2418 DEFINED AT LINE 98
RST4:               2420 DEFINED AT LINE 99
RST5:               2428 DEFINED AT LINE 100
RST6:               2430 DEFINED AT LINE 101
RST7:               2438 DEFINED AT LINE 102
AT:                 2440 DEFINED AT LINE 103
                    > USED AT LINE 996
VARS:               2442 DEFINED AT LINE 104
BRAK:               2476 DEFINED AT LINE 105
SLISH:              2478 DEFINED AT LINE 106
BRIK:               247A DEFINED AT LINE 107
UP:                 247C DEFINED AT LINE 108
LINPTR:             247E DEFINED AT LINE 109
                    > USED AT LINE 218
                    > USED AT LINE 226
                    > USED AT LINE 317
                    > USED AT LINE 338
                    > USED AT LINE 433
                    > USED AT LINE 479
SPAC:               2480 DEFINED AT LINE 110
EXCLAM:             2482 DEFINED AT LINE 111
                    > USED AT LINE 230
QUOTE:              2484 DEFINED AT LINE 112
NUMBR:              2486 DEFINED AT LINE 113
                    > USED AT LINE 204
                    > USED AT LINE 217
                    > USED AT LINE 270
                    > USED AT LINE 283
                    > USED AT LINE 335
                    > USED AT LINE 490
DOLLAR:             2488 DEFINED AT LINE 114
PERCNT:             248A DEFINED AT LINE 115
                    > USED AT LINE 827
AMPERS:             248C DEFINED AT LINE 116
                    > USED AT LINE 234
                    > USED AT LINE 288
                    > USED AT LINE 332
                    > USED AT LINE 444
                    > USED AT LINE 475
                    > USED AT LINE 972
QUITE:              248E DEFINED AT LINE 117
                    > USED AT LINE 410
                    > USED AT LINE 412
PAREN:              2490 DEFINED AT LINE 118
PARIN:              2492 DEFINED AT LINE 119
STAR:               2494 DEFINED AT LINE 120
                    > USED AT LINE 464
PLUS:               2496 DEFINED AT LINE 121
COMMA:              2498 DEFINED AT LINE 122
                    > USED AT LINE 171
                    > USED AT LINE 1139
MINUS:              249A DEFINED AT LINE 123
PERIOD:             249C DEFINED AT LINE 124
                    > USED AT LINE 169
                    > USED AT LINE 641
                    > USED AT LINE 679
                    > USED AT LINE 702
SLASH:              249E DEFINED AT LINE 125
EVALPT:             24A0 DEFINED AT LINE 127
                    > USED AT LINE 747
                    > USED AT LINE 764
SV1:                24A2 DEFINED AT LINE 128
SV2:                24A4 DEFINED AT LINE 129
SV3:                24A6 DEFINED AT LINE 130
SV4:                24A8 DEFINED AT LINE 131
SV5:                24AA DEFINED AT LINE 132
RESULT:             24AC DEFINED AT LINE 133
                    > USED AT LINE 963
                    > USED AT LINE 971
                    > USED AT LINE 994
LINUMB:             24AE DEFINED AT LINE 134
                    > USED AT LINE 263
                    > USED AT LINE 373
CURENT:             24B0 DEFINED AT LINE 135
                    > USED AT LINE 280
                    > USED AT LINE 447
                    > USED AT LINE 496
VALVAR:             24B2 DEFINED AT LINE 136
                    > USED AT LINE 930
                    > USED AT LINE 934
COLN:               24B4 DEFINED AT LINE 138
SEMI:               24B6 DEFINED AT LINE 139
LESS:               24B8 DEFINED AT LINE 140
EQAL:               24BA DEFINED AT LINE 141
GRAT:               24BC DEFINED AT LINE 142
DECBUF:             24BE DEFINED AT LINE 144
                    > USED AT LINE 572
                    > USED AT LINE 602
LASTD:              24C2 DEFINED AT LINE 145
DELIM:              24C3 DEFINED AT LINE 146
                    > USED AT LINE 195
LINBUF:             24C4 DEFINED AT LINE 147
                    > USED AT LINE 1085
                    > USED AT LINE 1112
STACK:              2540 DEFINED AT LINE 155
                    > USED AT LINE 193
PRGM:               2540 DEFINED AT LINE 156
                    > USED AT LINE 290
                    > USED AT LINE 337
RSTRT:              F800 DEFINED AT LINE 166
START:              F810 DEFINED AT LINE 193
                    > USED AT LINE 208
                    > USED AT LINE 214
                    > USED AT LINE 296
                    > USED AT LINE 470
                    > USED AT LINE 629
LOOP:               F81D DEFINED AT LINE 203
                    > USED AT LINE 451
                    > USED AT LINE 504
LOOP2:              F82F DEFINED AT LINE 210
                    > USED AT LINE 231
EQSTRT:             F832 DEFINED AT LINE 214
                    > USED AT LINE 239
LOOP3:              F858 DEFINED AT LINE 233
                    > USED AT LINE 225
                    > USED AT LINE 228
LXHN:               F865 DEFINED AT LINE 244
                    > USED AT LINE 216
                    > USED AT LINE 227
                    > USED AT LINE 428
CPHD:               F869 DEFINED AT LINE 253
                    > USED AT LINE 294
EXEC:               F86F DEFINED AT LINE 263
                    > USED AT LINE 207
                    > USED AT LINE 222
SKIP:               F876 DEFINED AT LINE 267
OUTX:               F87A DEFINED AT LINE 270
STMNT:              F880 DEFINED AT LINE 280
                    > USED AT LINE 206
LST2:               F894 DEFINED AT LINE 294
                    > USED AT LINE 312
NXTXT:              F8AE DEFINED AT LINE 317
                    > USED AT LINE 359
                    > USED AT LINE 430
LOOKAG:             F8B2 DEFINED AT LINE 319
                    > USED AT LINE 322
OUTH:               F8B8 DEFINED AT LINE 326
                    > USED AT LINE 743
FIND:               F8BA DEFINED AT LINE 332
                    > USED AT LINE 210
                    > USED AT LINE 425
FND2:               F8C6 DEFINED AT LINE 338
                    > USED AT LINE 361
NXTUU:              F8D1 DEFINED AT LINE 348
                    > USED AT LINE 341
FND3:               F8D9 DEFINED AT LINE 359
                    > USED AT LINE 238
EVIL:               F8DF DEFINED AT LINE 367
                    > USED AT LINE 268
ANDT:               F8F8 DEFINED AT LINE 385
                    > USED AT LINE 378
CPBD:               F90B DEFINED AT LINE 416
                    > USED AT LINE 434
                    > USED AT LINE 487
SKP2:               F911 DEFINED AT LINE 425
                    > USED AT LINE 286
DELT:               F924 DEFINED AT LINE 434
                    > USED AT LINE 440
FITIT:              F931 DEFINED AT LINE 444
                    > USED AT LINE 435
INSRT:              F936 DEFINED AT LINE 447
                    > USED AT LINE 427
                    > USED AT LINE 429
CNTLN:              F941 DEFINED AT LINE 453
                    > USED AT LINE 457
OPEN:               F948 DEFINED AT LINE 461
SLIDE:              F962 DEFINED AT LINE 483
                    > USED AT LINE 488
DON:                F96C DEFINED AT LINE 490
MOVL:               F977 DEFINED AT LINE 498
                    > USED AT LINE 503
POLCAT:             F982 DEFINED AT LINE 543
                    > USED AT LINE 625
                    > USED AT LINE 635
                    > USED AT LINE 712
PRNT2:              F99B DEFINED AT LINE 572
                    > USED AT LINE 303
                    > USED AT LINE 386
CVD1:               F9A1 DEFINED AT LINE 574
                    > USED AT LINE 595
ZRSUP:              F9C2 DEFINED AT LINE 603
                    > USED AT LINE 606
PNTMSG:             F9C9 DEFINED AT LINE 610
                    > USED AT LINE 307
STRMSG:             F9CA DEFINED AT LINE 615
                    > USED AT LINE 1121
OUTMSG:             F9CB DEFINED AT LINE 616
                    > USED AT LINE 621
CONTC:              F9D7 DEFINED AT LINE 625
                    > USED AT LINE 619
INCH:               F9E3 DEFINED AT LINE 635
                    > USED AT LINE 627
                    > USED AT LINE 649
                    > USED AT LINE 655
                    > USED AT LINE 945
                    > USED AT LINE 1097
INA:                F9FE DEFINED AT LINE 665
                    > USED AT LINE 636
ASCII:              FA03 DEFINED AT LINE 669
                    > USED AT LINE 620
                    > USED AT LINE 667
OUTCH:              FA05 DEFINED AT LINE 678
                    > USED AT LINE 381
                    > USED AT LINE 1129
                    > USED AT LINE 1131
                    > USED AT LINE 1144
OUTC:               FA0E DEFINED AT LINE 691
                    > USED AT LINE 695
OUTCAS:             FA1B DEFINED AT LINE 698
                    > USED AT LINE 658
OUTA:               FA1C DEFINED AT LINE 702
                    > USED AT LINE 687
                    > USED AT LINE 693
OUTB:               FA23 DEFINED AT LINE 712
                    > USED AT LINE 713
EVAL:               FA2D DEFINED AT LINE 733
                    > USED AT LINE 370
                    > USED AT LINE 933
                    > USED AT LINE 954
                    > USED AT LINE 969
NXTRM:              FA30 DEFINED AT LINE 739
                    > USED AT LINE 748
TERM:               FA43 DEFINED AT LINE 758
                    > USED AT LINE 744
EVAL2:              FA56 DEFINED AT LINE 781
                    > USED AT LINE 771
HSUBB:              FA5B DEFINED AT LINE 786
                    > USED AT LINE 857
EVAL3:              FA62 DEFINED AT LINE 797
                    > USED AT LINE 782
MULT1:              FA6D DEFINED AT LINE 805
                    > USED AT LINE 815
MULT2:              FA76 DEFINED AT LINE 813
                    > USED AT LINE 810
EVAL4:              FA7C DEFINED AT LINE 822
                    > USED AT LINE 798
DIV:                FA8A DEFINED AT LINE 845
                    > USED AT LINE 584
                    > USED AT LINE 826
DIV1:               FA91 DEFINED AT LINE 849
                    > USED AT LINE 864
DIV2:               FA9B DEFINED AT LINE 857
                    > USED AT LINE 855
DIV3:               FAA4 DEFINED AT LINE 862
                    > USED AT LINE 859
EVAL5:              FAA9 DEFINED AT LINE 869
                    > USED AT LINE 823
EVIL5:              FAAD DEFINED AT LINE 875
EVIL6:              FABA DEFINED AT LINE 890
                    > USED AT LINE 876
EVIL7:              FAC5 DEFINED AT LINE 906
                    > USED AT LINE 891
GETVAL:             FACC DEFINED AT LINE 920
                    > USED AT LINE 733
                    > USED AT LINE 762
VAR:                FAE3 DEFINED AT LINE 942
                    > USED AT LINE 926
VAR1:               FAEF DEFINED AT LINE 953
                    > USED AT LINE 943
VAR2:               FAF5 DEFINED AT LINE 958
                    > USED AT LINE 264
ARRAY:              FAFF DEFINED AT LINE 969
                    > USED AT LINE 986
CONVP:              FB0C DEFINED AT LINE 982
                    > USED AT LINE 374
                    > USED AT LINE 958
OUTD:               FB1F DEFINED AT LINE 1003
                    > USED AT LINE 711
PWRS10:             FB21 DEFINED AT LINE 1009
                    > USED AT LINE 573
TSTN:               FB2B DEFINED AT LINE 1018
                    > USED AT LINE 1034
                    > USED AT LINE 1048
CVTLN:              FB33 DEFINED AT LINE 1028
                    > USED AT LINE 205
CVBIN:              FB36 DEFINED AT LINE 1034
                    > USED AT LINE 920
CBLOOP:             FB3D DEFINED AT LINE 1040
                    > USED AT LINE 1064
INLN6:              FB59 DEFINED AT LINE 1069
                    > USED AT LINE 1108
NEWLIN:             FB65 DEFINED AT LINE 1081
                    > USED AT LINE 1070
                    > USED AT LINE 1093
INLN:               FB68 DEFINED AT LINE 1085
                    > USED AT LINE 931
                    > USED AT LINE 1028
INLN5:              FB6B DEFINED AT LINE 1090
                    > USED AT LINE 1101
INLN2:              FB72 DEFINED AT LINE 1097
                    > USED AT LINE 1077
                    > USED AT LINE 1106
INLN3:              FB7B DEFINED AT LINE 1105
INLN4:              FB83 DEFINED AT LINE 1110
QUOTE2:             FB8B DEFINED AT LINE 1117
                    > USED AT LINE 368
STRNG:              FB8C DEFINED AT LINE 1121
                    > USED AT LINE 197
CRLF:               FB93 DEFINED AT LINE 1128
                    > USED AT LINE 309
                    > USED AT LINE 1081
PRLF:               FB98 DEFINED AT LINE 1130
                    > USED AT LINE 1113
NULL:               FBA0 DEFINED AT LINE 1140
                    > USED AT LINE 1146
OKM:                FBAB DEFINED AT LINE 1150
                    > USED AT LINE 196